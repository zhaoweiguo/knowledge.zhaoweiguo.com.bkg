分布式系统
##########


.. sidebar:: Table of Contents

    .. contents::



分布式系统的核心问题
====================


主要内容::

    一致性问题 共识问题

分布式计算的8个谬论::

    The network is reliable.
    Latency is zero.
    Bandwidth is infinite.
    The network is secure.
    Topology doesn't change.
    There is one administrator.
    Transport cost is zero.
    The network is homogeneous.

一致性
------

::

    分布式集群中多个服务节点,对给定的操作,根据给定的协议,对处理结果对外保持一致. 
    不在乎结果是否正确,而是保证对外呈现的状态一致.所有节点失败也是一种一致.

引起不一致的因素::

    节点间网络通信的不可靠,消息延迟,消息乱序,内容错误.
    节点处理时间无法保证: 结果可能错误,或者节点宕机.

满足一致性的要求::

    1. 有限时间完成请求的处理
    2. 不同节点完成的结果相同
    3. 决策的结果必须是某个节点提出的提案.

强一致性需要::

    顺序保证. 时钟

 

共识
----

::

    对某一操作,达成一直的过程.
    通常达成这个一过程需要集群中的节点进行广播投票.
    但是由于分布式节点间的不稳定: 网络不可靠,节点宕机,假消息等.达成共识并不容易.

针对如上不稳定的情况,把故障分为::

    非拜占庭错误(出现消息不响应,但是消息不会被篡改)和
    拜占庭错误(存在伪造消息的情况).

共识算法::

    CFT类 针对非拜占庭错误有: 
        PAXOS 算法.
        Raft算法.
        容错较好,处理快,保证不超过一半节点故障.
    BFT类 针对拜占庭错误有:
        PBFT 确定性算法,
        POW 工作量证明的概率算法.

主要定义简介
------------

FLP不可能原理::

    异步系统,不存在任意场景下都能实现共识的算法.


分布式同步::

    系统各个节点时钟误差存在上限,消息传递必须在规定时间内完成,否则认为失败.(传统的分布式中,统一时钟,超时失败等都是同步)

分布式异步::

    系统各个节点时钟存在较大差距,消息传递时间任意长(无法判断节点故障还是网络延迟)

CAP 一致性::

    分布式计算系统不可能同时保证 强一致性,高可用性,高分区容忍性.

折中选择::

    弱化一致性:对结果不敏感的应用可以允许最终一致. CouchDB
    弱化可用性:对结果一致性敏感,银行,当系统故障时会拒绝服务.MongoDB, Redis, MapReduce 为此设计. 
        PAXOS 等共识算法主要处理这种情况. 可能存在无法提供可用结果的情况,同时允许部分节点离线.
    弱化分区容忍性: 网络分区出现概率较小, 两阶段提交算法,关系型数据库,ZK主要考虑这种情况设计的.
        实践中网络可用是双通道,弱化网络不稳定因素.



分布式系统的设计目标一般包括::

    扩展性 :增加机器不改变或极少改变系统行为，并能获得近似线性的性能提升；
    性能 :指分布式系统进行服务时的延时和吞吐率是满足用户需要的；
    可用性 :分布式系统的核心需求，表示分布式系统是否处于整体可服务并且一直可服务的状态；
    容错性 :系统发生错误时，系统有对错误进行规避和恢复的能力。

一套分布式系统的主要物理要素包括节点的数目以及节点间的距离。仅这两点的更改就会引入以下限制::

    节点数增加会导致系统整体出错概率增大
    节点数增加会导致节点间通信量增加
    节点间距离增加会导致系统最优（或部分）性能变差

抛开工程的视角，仅从理论层面看，分布式系统也存在着如下三类视角的系统划分::

    1. 保持一致: 
       系统中相关数据间的逻辑关系应当是正确和完整的。
       极端情况下，从系统中任意部分读取而获得的数据应当都为最近写入的数据；
    2. 处理失效:
       分布式系统可能出现的失效状况有三类：节点失效、网络分区失效、拜占庭失效。
       极端情况下，系统的执行和操作不会受到任何系统内部失效的影响；
    3. 时钟同步:
       分布式系统有两种模型：同步系统和异步系统。
       同步系统会确保所有执行过程的步调一致，且各执行过程有精确的时钟。
            即任意处理过程能够得到精确的执行流程的偏序关系，也就意味着每个处理过程和通信都在有限的时间内进行。
       异步系统则相反，没有任何时序性保证。
            即各处理过程是完全以自己的节拍在运行，不存在有效的同步时钟，也意味着过程间的通信延时可能会趋于无穷大。


.. note:: 不幸的是，在实际应用中，理想的分布式系统实际是不可能实现的。



服务保护
========

::

    限流
    熔断
    降级

熔断
----

熔断模式可以防止应用程序不断地尝试可能超时和失败的服务，能达到应用程序执行而不必等待下游服务修正错误服务。
熔断器模式最牛的是能让应用程序自我诊断下游系统的错误是否已经修正，如果没有，不放量去请求，如果请求成功了，慢慢的增加请求，再次尝试调用。

* 阿里出的 Sentinel
* 最多人使用的 Hystrix。

降级
----

降级的本质::

    降级就是为了解决资源不足和访问量增加的矛盾

    在有限的资源情况下，为了能抗住大量的请求，就需要对系统做出一些牺牲，有点 “弃卒保帅” 的意思。
    放弃一些功能，保证整个系统能平稳运行

降级牺牲的是什么::

    1. 强一致性变成最终一致性:
    大多数的系统是不需要强一致性的。
    强一致性就要求多种资源的占用，减少强一致性就能释放更多资源
    这也是我们一般利用消息中间件来削峰填谷，变强一致性为最终一致性，也能达到效果

    2. 干掉一些次要功能:
    停止访问不重要的功能，从而释放出更多的资源
    举例来说，比如电商网站，评论功能流量大的时候就能停掉，当然能不直接干掉就别直接，最好能简化流程或者限流最好

    3. 简化功能流程:
    把一些功能简化掉

降级的注意点::

    1. 对业务进行仔细的梳理和分析
    哪些是核心流程必须保证的，哪些是可以牺牲的


    2. 什么指标下能进行降级
    吞吐量、响应时间、失败次数等达到一个阈值才进行降级处理

    3. 如何降级
    降级最简单的就是在业务代码中配置一个开关或者做成配置中心模式，直接在配置中心上更改配置，推送到相应的服务。

限流
----

限流的目的::

    通过对并发访问进行限速。


限流有哪些行为::

    1. 拒绝服务
    最简单的方式，把多余的请求直接拒绝掉
    做的高大上一些，可以根据一定的用户规则进行拒绝策略。

    2. 服务降级
    降级甚至关掉后台的某些服务。

    3. 特权请求
    在多租户或者对用户进行分级时，可以考虑让一些特殊的用户有限处理，其他的可以考虑干掉

    4. 延时处理
    可以利用队列把请求缓存住。削峰填谷。


限流的实现方式::

    1. 计数器
    最简单的实现方式 ，维护一个计数器，来一个请求计数加一，达到阈值时，直接拒绝请求。
    一般实践中用 ngnix + lua + redis 这种方式，redis 存计数值

    2. 漏斗模式
    流量就像进入漏斗中的水一样，而出去的水和我们系统处理的请求一样，当流量大于漏斗的流出速度，就会出现积水，水对了会溢出。
    漏斗很多是用一个队列实现的，当流量过多时，队列会出现积压，队列满了，则开始拒绝请求。

    3. 令牌桶
    令牌通和漏斗模式很像，主要的区别是增加了一个中间人，
    这个中间人按照一定的速率放入一些 token，
    然后，处理请求时，需要先拿到 token 才能处理，
    如果桶里没有 token 可以获取，则不进行处理。

限流的一些注意点::

    限流越早设计越好，架构成型后，不容易加入
    限流模块不要成为系统的瓶颈，性能要求高
    最好有个开关，可以直接介入
    限流发生时，能及时发出通知事件
    限流发生时，给用户提供友好的提示

三者的关系::

    熔断强调的是服务之间的调用能实现自我恢复的状态；
    限流是从系统的流量入口考虑，从进入的流量上进行限制，达到保护系统的作用；
    降级，是从系统内部的平级服务或者业务的维度考虑，流量大了，可以干掉一些，保护其他正常使用；


    熔断是降级方式的一种；
    降级又是限流的一种方式；
    三者都是为了通过一定的方式去保护流量过大时，保护系统的手段。


限流是防止上游服务调用量过大导致当前服务被压垮，熔断是预防下游服务出现故障时阻断对下游的调用。

.. image:: /images/architectures/limiting_fusing1.png

熔断器设计模式是基于 AOP 对所有的请求调用进行拦截，在请求调用前做状态判断是否熔断，请求调用后做计数统计，并根据策略做熔断状态转移。:

.. image:: /images/architectures/limiting_fusing2.png


熔断器涉及三种状态和四种状态转移:

.. image:: /images/architectures/limiting_fusing3.png

设计模式思想源自 Microsoft 《Circuit Breaker Pattern》::

    在熔断领域中，还有大名鼎鼎的 Hystrix （有 Java 和 Golang 版本）
        是 Netflix 开源的限流熔断项目，它支持并发请求，异步上报统计结果提高了并发性

根据服务发现和服务调用的不同，主要有三种方式::

    直连模式，服务 A 直接访问 服务 B
    集中代理模式，通过引入内网网关做代理，调用时通过网关做转发和负载均衡
    还有目前比较火的 服务网格模式 Service Mesh，也叫边车模式 SideCar

linearizable语义
================

线性化(linearizable)是分布式系统中比较重要的概念::

    是对单对象上的单个操作的一种顺序保证，
    它提供了对于「同一对象的一系列读写操作都是按照实时时间排序」的保证。

    简单说，linearizability保证对于一个对象的写操作一旦完成，需要立即被后续读操作看到，
    即读操作一定是读到该对象的最新的值。

    从这个角度看，linearizability 与 atomic consistency是同义词
    即CAP原则中的Consistency


参考
====

* 降级 - 熔断 - 限流 - 傻傻分不清楚: https://zhuanlan.zhihu.com/p/61363959
* https://mp.weixin.qq.com/s/R_43L2bkrSHjnPEaYkK6Tw

