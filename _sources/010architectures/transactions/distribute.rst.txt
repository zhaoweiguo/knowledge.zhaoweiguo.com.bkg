分布式事务
##########

.. sidebar:: 目录

    .. contents::


* 关联: :ref:`CAP <cap>`

多个服务同时访问多个数据源的事务处理机制，严谨地说，它更应该被称为 “在分布式服务环境下的事务处理机制”。



可靠事件队列
============

.. figure:: /images/architectures/transaction5.jpg

   可靠事件队列时序图

操作步骤::

    1. 最终用户向 Fenix's Bookstore 发送交易请求：购买一本价值 100 元的《深入理解 Java 虚拟机》
    2. Fenix's Bookstore 应该对用户账户扣款、商家账户收款、库存商品出库这三个操作有一个出错概率的先验评估，
        根据出错概率的大小来安排它们的操作顺序（这个一般体现在程序代码中，有一些大型系统也可能动态排序）
        比如:
            最有可能出错的地方，是用户购买了，但是系统不同意扣款，或者是账户余额不足；
            其次是商品库存不足；
            最后是商家收款一般不会遇到什么意外

            最后的顺序就应该是最容易出错的最先进行，即：账户扣款 → 仓库出库 → 商家收款。
    3. 账户服务进行扣款业务
        如果扣款成功，就在自己的数据库建立一张消息表，里面存入一条消息:
            事务 ID：UUID；
            账户扣款：100 元（状态：已完成）；
            仓库出库《深入理解 Java 虚拟机》：1 本（状态：进行中）
            某商家收款：100 元（状态：进行中）
        注意:
            这个步骤中 “扣款业务” 和 “写入消息” 是依靠同一个本地事务写入自身数据库的
    4. 系统建立一个消息服务
        定时轮询消息表，将状态是 “进行中” 的消息同时发送到库存和商家服务节点中去。

定时轮询过程会产生以下几种情况::

    1. 商家和仓库服务成功完成了收款和出库工作， 向用户账户服务器返回成功执行结果，
        用户账户服务把消息状态从 “进行中” 更新为 “已完成”。
        整个事务宣告顺利结束，达到最终一致性的状态。

    2. 商家或仓库服务有某些或全部因网络原因，未能收到来自用户账户服务的消息。
        此时，由于用户账户服务器中存储的消息状态，一直处于 “进行中”，
        所以消息服务器将在每次轮询的时候，持续地向对应的服务重复发送消息。
        注意:
            所有被消息服务器发送的消息都必须具备幂等性。
            通常我们的设计是让消息带上一个唯一的事务 ID，以保证一个事务中的出库、收款动作只会被处理一次

    3. 商家或仓库服务有某个或全部无法完成工作。
        比如仓库发现《深入理解 Java 虚拟机》没有库存了
        此时，仍然是持续自动重发消息，直至操作成功（比如补充了库存），或者被人工介入为止。

    4. 商家和仓库服务成功完成了收款和出库工作，但回复的应答消息因网络原因丢失。
        此时，用户账户服务仍会重新发出下一条消息，但因消息幂等，所以不会导致重复出库和收款，
        只会导致商家、仓库服务器重新发送一条应答消息。
        此过程会一直重复，直至双方网络恢复。
    
    说明:
        有一些支持分布式事务的消息框架，如 RocketMQ
        原生就支持分布式事务操作，这时候前面提到的情况 2、4 也可以交给消息框架来保障。

.. note:: 这种靠着持续重试来保证可靠性的操作，在计算机中就非常常见，它有个专门的名字，叫做 “最大努力交付”（Best-Effort Delivery），比如 TCP 协议中的可靠性保障，就属于最大努力交付。


.. note:: 『可靠事件队列』被称为 “最大努力一次提交”（Best-Effort 1PC），意思就是系统会把最有可能出错的业务，以本地事务的方式完成后，通过不断重试的方式（不限于消息系统）来促使同个事务的其他关联业务完成。

缺点::

    可靠消息队列的整个实现过程完全没有任何隔离性可言。


TCC 事务
========

可靠消息队列缺少隔离性的问题::

    在线书店的场景事例中，如果缺乏了隔离性，就会带来一个显而易见的问题：超售。
    在书店的业务场景下，很有可能会出现这样的情况:
        两个客户在短时间内都成功购买了同一件商品
        而且他们各自购买的数量都不超过目前的库存，但他们购买的数量之和，却超过了库存

TCC: Try-Confirm-Cancel::

    除可靠消息队列以外的另一种常见的分布式事务机制
    它天生适合用于需要强隔离性的分布式事务中。

.. note:: 在具体实现上，TCC 的操作其实有点儿麻烦和复杂，它是一种业务侵入性较强的事务方案，要求业务处理过程必须拆分为 “预留业务资源” 和 “确认 / 释放消费资源” 两个子过程。

TCC 的实现过程分为了三个阶段::

    Try
        尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好事务需要用到的所有业务资源（保障隔离性）
    Confirm
        确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。
        注意，Confirm 阶段可能会重复执行，因此需要满足幂等性。
    Cancel：
        取消执行阶段，释放 Try 阶段预留的业务资源。
        注意，Cancel 阶段也可能会重复执行，因此也需要满足幂等性。


.. figure:: /images/architectures/transaction6.jpg

   TCC 事务操作时序


实例演示TCC 的执行过程::

    1. 最终用户向 Fenix's Bookstore 发送交易请求
       购买一本价值 100 元的《深入理解 Java 虚拟机》

    2. 创建事务，生成事务 ID，记录在活动日志中，进入 Try 阶段
        用户服务：检查业务可行性，
            可行的话，把该用户的 100 元设置为 “冻结” 状态，通知下一步进入 Confirm 阶段
            不可行的话，通知下一步进入 Cancel 阶段
        仓库服务：检查业务可行性
            可行的话，将该仓库的 1 本《深入理解 Java 虚拟机》设置为 “冻结” 状态，通知下一步进入 Confirm 阶段
            不可行的话，通知下一步进入 Cancel 阶段
        商家服务：检查业务可行性，不需要冻结资源

    3. 如果第二步中所有业务都反馈业务可行，就将活动日志中的状态记录为 Confirm，进入 Confirm 阶段
        用户服务：完成业务操作（扣减被冻结的 100 元）
        仓库服务：完成业务操作（标记那 1 本冻结的书为出库状态，扣减相应库存）
        商家服务：完成业务操作（收款 100 元）

    4. 如果第三步的操作全部完成了，事务就会宣告正常结束

    异常处理:
        1. 如果第三步中的任何一方出现了异常，不论是业务异常还是网络异常
            将会根据活动日志中的记录，来重复执行该服务的 Confirm 操作，即进行 “最大努力交付”
        2. 如果是在第二步，有任意一方反馈业务不可行，或是任意一方出现了超时
           将活动日志的状态记录为 Cancel，进入 Cancel 阶段：
            用户服务：取消业务操作（释放被冻结的 100 元）
            仓库服务：取消业务操作（释放被冻结的 1 本书）
            商家服务：取消业务操作（大哭一场后安慰商家谋生不易）
        3. 如果上一步全部完成了，事务就会宣告以失败回滚结束。
           而如果第五步中的任何一方出现了异常，不论是业务异常还是网络异常
           也都将会根据活动日志中的记录，来重复执行该服务的 Cancel 操作，即进行 “最大努力交付”


.. note:: TCC 其实有点类似于 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面，这就为它的实现带来了较高的灵活性，我们可以根据需要设计资源锁定的粒度。另外，TCC 在业务执行的时候，只操作预留资源，几乎不会涉及到锁和资源的争用，所以它具有很高的性能潜力

.. note:: 由于 TCC 的业务侵入性比较高，需要开发编码配合，在一定程度上增加了不少工作量。所以，通常我们并不会完全靠裸编码来实现 TCC，而是会基于某些分布式事务中间件（如阿里开源的 Seata）来完成，以尽量减轻一些编码工作量。

TCC缺点::
    
    TCC 最主要的限制是它的业务侵入性很强，带来它要求有很强的技术可控性
    比如有一个服务是调用支付宝的支付，我们没法让支付宝配合做「资金冻结」之类的操作

    这种情况只能考虑采用另外一种柔性事务方案：SAGA 事务

SAGA 事务
=========

.. important:: 基于数据补偿代替回滚的解决思路


SAGA 事务模式::

    一种提升 “长时间事务”（Long Lived Transaction）运作效率的方法
    大致思路是把一个大事务分解为可以交错运行的一系列子事务的集合。
    
    原本提出 SAGA 的目的，是为了避免大事务长时间锁定数据库的资源，
    后来才逐渐发展成将一个分布式环境中的大事务，分解为一系列本地事务的设计模式。

SAGA 由两部分操作组成::

    1. 把大事务拆分成若干个小事务，将整个分布式事务 T 分解为 n 个子事务，我们命名为 T1，T2，…，Ti，…，Tn
        每个子事务都应该、或者能被看作是原子行为。
        如果分布式事务 T 能够正常提交，那么它对数据的影响（最终一致性）就应该与连续按顺序成功提交子事务 Ti 等价
    2. 为每一个子事务设计对应的补偿动作，我们命名为 C1，C2，…，Ci，…，Cn

Ti 与 Ci 必须满足以下条件::

    1. Ti 与 Ci 都具备幂等性；
    2. Ti 与 Ci 满足交换律（Commutative）
    3. Ci 必须能成功提交
        即不考虑 Ci 本身提交失败被回滚的情况，如果出现就必须持续重试直至成功，或者要人工介入

.. note:: 如果 T1 到 Tn 均成功提交，那么事务就可以顺利完成。否则，我们就要采取以下两种恢复策略之一

恢复策略::

    1. 正向恢复（Forward Recovery）
       如果 Ti 事务提交失败，则一直对 Ti 进行重试，直至成功为止（最大努力交付）
       这种恢复方式不需要补偿，适用于事务最终都要成功的场景，比如:
       在别人的银行账号中扣了款，就一定要给别人发货。
       正向恢复的执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn

    2. 反向恢复（Backward Recovery）
        如果 Ti 事务提交失败，则一直执行 Ci 对 Ti 进行补偿，直至成功为止（最大努力交付）
        这里要求 Ci 必须（在持续重试后）执行成功。
        反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1











