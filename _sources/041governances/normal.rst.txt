常用
####

智者::

    规则对智者来说是指导，对愚蠢者来说是遵从

原则::

    原则不超过10个
    能够写在一个海报上
    不然大家记不住
    原则越多，越易重叠和冲突


反脆弱
======


* 混乱猴子（Chaos Monkey），在一天的特定时段随机停掉服务器或机器。知道这可能会发生在生产环境，意味着开发人员构建系统时不得不为它做好准备。
* 混乱大猩猩（Chaos Gorilla）用于随机关闭整个可用区（AWS 中对数据中心的叫法）
* 延迟猴子（Latency Monkey）在系统之间注入网络延迟。


让软件拥抱和引发故障，并构建系统来应对::

    当失败发生后从失败中学习的重要性，并在错误真正发生时采用不指责文化。
    作为这种学习和演化过程的一部分，开发人员被进一步授权，他们每个人都需要负责管理他的生产服务。


“理解分布式系统所需的思维方式上的转变”
“事情将会失败”
“你的系统正分布在多台机器上（它们会发生故障），通过网络（它也是不可靠的）通信，这些都会使你的系统更脆弱，而不是更健壮。”
“在分布式架构下，准备好如何应对各种故障的发生是非常重要的”::

    1. 超时
    2. 断路器
    3. 舱壁 （bulkhead）
      3.1 共用「连接池」: 连接池被一个微服务占满，所有的请求都等待。
      3.2 关注点分离: 一个微服务的2个功能，一个有问题被断路影响另一个。
      舱壁最重要，超时和断路器能够帮助你在资源受限时释放它们，但舱壁可以在第一时间确保它们不成为限制。
      实现拒绝请求的舱壁，以避免资源达到饱和，这被称为减载 （load shedding）。
      有时拒绝请求是避免重要系统变得不堪重负或成为多个上游服务瓶颈的最佳方法。
    4. 隔离

Jeff Dean 在他的演讲“Challenges in Building Large-Scale Information Retrieval Systems”::

    2009 年 WSDM 会议:
    设计应该“考虑 10 倍容量的增长，但超过 100 倍容量时就要重写了”。

自动伸缩::

    响应型伸缩和预测型伸缩

微服务架构原则::

    1. 围绕业务建模
    2. 自动化的文化
      微服务引入了很多复杂性，其中的关键部分是，我们不得不管理大量的服务。
      解决这个问题的一个关键方法是，拥抱自动化文化。
      前期花费一定的成本，构建支持微服务的工具是很有意义的。
      自动化测试 必不可少，因为相比单块系统，确保我们大量的服务能正常工作是一个更复杂的过程。
    3. 隐藏内部实现细节
    4. 一切都去中心化
    5. 独立部署
    6. 隔离失败
    7. 高度可观察


架构师设计
==========

如何进行性能测试，性能测试的流程是什么？性能测试的主要关注指标有哪些？


怎么理解领域驱动设计DDD?
DDD的优缺点是什么？

导致系统故障无法正常访问的原因有哪些？保障系统稳定高可用的方案有哪些？
如何保护数据库中存储的用户密码，用时序图展示「用户密码」加密存储与登录验证的过程

架构师的主要能力:
1. 编程
2. 基础技术掌握能力
3. 常用技术产品的理解与应用能力
4. 性能优化与分析故障的能力
5. 常用架构模式和框架的理解 与应用能力
6. 建模以及设计文档的方法和能力
7. 业务理解与功能模块及非功能模块拆解能力
8. 快速学习能力
9. 沟通与领导能力




最后我想再引用 一个真实的故事，是来源于 NASA 的著名文章《为什么要探索太空？》，文章的背景是来源于 1970 年，赞比亚修女 Mary Jucunda 给 NASA 科学家 Ernst Stuhlinger 博士写了一封信，信中，Mary Jucunda 修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。Ernst Stuhlinger 在回信中写到一个真实的故事如下：

那是在 400 年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气。“我们还在受瘟疫的苦，” 他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！” 伯爵听到后不为所动。“我会尽可能地接济大家，” 他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。” 果不其然，他的工作（以及同时期其他人的努力）赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。


技术债
======

::

    技术债是无法避免的，只是产生技术债或多或少的问题，不还技术债付出的代价更高。
    Technical debt（技术债 / 技术负债）= design debt（设计负债）= code debt（代码负债）

    抬头看天是为了找到正确的方向，有时因为一些原因（如开发时间紧）往别的方向上拉了一会，一定要记得这是临时行为，而且这些临时行为会导致「技术债」

.. figure:: /images/architectures/technical_debt.png

   The Future of Managing Technical Debt
   这张全景图主要从两个方向来分析技术债对于软件的影响：可维护性（Maintainability）、可演进性（Evolvability），同时结合问题的可见性（Visibility）分析技术债对于软件开发过程的影响。

`可维护性（Maintainability）` 主要指的是狭义上的代码问题，即代码本身可读性如何、是否容易被他人所理解、是否有明显的代码坏味道、是否容易扩展和增强。

`可演进性（Evolvability）` 指的是系统适应变化的能力。 在生物学中它指的是种群产生适应性的遗传多样性，从而通过自然选择进化的能力。对软件系统来说，可演进性（Evolvability）本质上一种架构的元特征（Meta-Characteristic），描述的是软件架构趋于目标演进的能力，演进目标并不仅局限于支撑功能快速迭代（Iteration）的灵活性（Flexibility），也可以是其他的架构属性（Quality Attribute），比如高可用性、可扩展性。

针对 `可见性` 的分析可以依赖于外部视角：对于最终用户来说，软件功能、设计和用户体验等方面的缺陷，导致用户无法顺利完成既定的业务流程，那么对于用户不可见的代码问题就升级为了可见的质量问题；对于需求提供方来说，臃肿的技术架构、散落各处的业务逻辑导致产品无法快速响应需求变化，导致交付延期，那么对于无技术背景的业务人员来说，难以理解的、不可见的架构问题就升级为了可见的软件交付风险。

分类
====

* 技术债务
* 运营债务

技术债大概分为三大类::

    文档负债（包括需求分析负债，开发文档负债，测试文档负债）
    代码负债（包括架构负债，编码负债，业务负债）
    管理负债（包括工期负债，人员负债，协同负债，成本负债）

编码负债::

    1. 代码命名规范：代码命名没有规范，存在大量杂乱不堪的命名代码。
    2. 代码复杂度：条件语句过多，流程控制过于复杂，代码嵌套过多。
    3. 代码耦合度：代码中参数，类，接口高耦合，需要大量修改代码。
    4. 代码行数：存在大量未使用的代码。


技术债治理的四条原则
====================

1. 核心领域优于其他子域
-----------------------

::

    核心域（Core Domain）
    支撑子域（Supporting SubDomain）
    通用子域（Generic Subdomain）

.. note:: The Core Domain should deliver about 20% of the total value of the entire system, be about 5% of the code base, and take about 80% of the effort.

2. 可演进性优于可维护性
-----------------------

技术债导致的可演进性问题大多和架构相关，比如服务和服务之间的循环依赖、模块和模块之间的过度耦合、缺少模块化和服务边界的 “大泥球” 组件等，在添加新的功能时，这些架构的坏味道会给产品功能的迭代造成不少麻烦。比如服务之间如果存在循环依赖的问题，当你对系统进行少量更改时，它可能会对其他模块产生连锁反应，这些模块可能会产生意想不到的错误或者异常。此外，如果两个模块过度耦合、相互依赖，则单个模块的重用也变得极其困难。

可演进性问题可能会直接导致开发速度滞后，功能无法按期交付，使项目出现重大的交付风险。而且问题发生的时候往往已经 “积重难返”，引入的技术债务没有在合适的时间得到解决，其产生的影响会像 “滚雪球” 一样越滚越大。在我所经历过的项目中有一个不太合理的模型设计，由于错过了最佳的纠正时间，为了实现新的业务功能最终不得不做服务拆分时，发现需要修改的调用点竟有 1000 多处，而且这些修改点很难借助于 IDE 或者重构工具来一次性解决，不但增加了团队的负担还直接导致了后续功能需求的交付延期。

和可演进性问题相比，高复杂度、霰弹式修改等代码级别问题也很重要，但是相对来说我们更加关注软件适应变化的能力，通过提升软件系统的适应性减少软件最终交付价值的前置时间，快速收集真实用户的反馈，持续不断迭代产品、完善设计。

所以我们在治理技术债时坚持的另外一个原则是 `“可演进性优于可维护性”` 。如果把上文提到的可维护性和可演进性使用不同的颜色来标识的话（红色表示可演进性问题、蓝色表示可维护性问题），我们可以得到这样的结果：

3. 明确清晰的责任定义优于松散无序的任务分配
-------------------------------------------

* 刻意设计（Intentional Design）
* 浮现式设计（Emergent Design）

4. 主动预防优于被动响应
-----------------------

这个原则本质上是缩短反馈周期，提前发现潜在问题，除了必要的代码审查流程（Code Review）、提升团队能力之外还可以借助于自动化工具来提前发现问题。

对于代码可维护性方面，很多比较成熟的静态代码扫描工具都可以自动识别这类问题，比如 SonarQube、checkstyle 等，但是仅仅在持续集成上（Continuous Integration）运行还不够，需要和团队一起自定义扫描规则，并把检查代码扫描报告作为代码审查的一部分，逐步形成一种正向的反馈机制。

在技术债治理的过程中，实践可以剪裁，甚至原则也可以妥协，因为比这几条原则更重要的是获得关键干系人的支持。作为技术人员或者技术领导者，不仅要有前瞻性的技术洞察力、锐意变革的魄力，还需要以 “旁观者” 视角，置身事外地观察自己所处的环境，思考技术改进究竟对于自己、他人、团队、公司和客户究竟产生了什么价值。


减少债务的方法
==============

1. 评估你的处境, 弄清楚你欠了多少
---------------------------------

这一步最关键。一旦团队决定必须偿还他们的技术债务（这不是一个容易的决定 —— 而且必须与业务一起做出），他们就必须弄清楚他们实际上欠了多少债务。最好的方法是进行自上而下的设计和代码审查。

步骤::

    首先看看你的设计文档。
        它是最新的吗？
        它是否准确地描述了设计中最重要的点？
    然后，你可能想首先审查下代码的哪些部分给你带来了最大的麻烦
        哪些部分最难修改？
        哪些地方出错率最高？
        那些部分对你的业务来说最重要？
    找出这些问题的答案，可以帮助你对你需要做的事情进行排序，找出方法改善你的处境。



2. 停止引入新债务
-----------------

最难的部分是学会组织文化变革，这样你就不会让积累的债务超过合理的服务能力。在用户故事中包含债务偿还活动。

为了修复发现的问题，你必须花时间来实现修复，这意味着你在纠正问题时会搁置新的开发。关于这一点，没有什么完美的方法，无论你采取什么方法，你都需要与业务协商如何平衡技术债务偿还和新功能开发。下面是一些我们认为有效的策略。

3. 选择债务偿还策略
-------------------

策略::

    “最高利率优先”
        首先考虑承担影响最大的任务
    “最低余额优先”
        首先处理最小的修复

4. 按计划行事！
---------------

关键是，让偿还债务成为你长期活动的一部分。确保你能在合理的时间内偿还，而不是让它越积越多。

5. 跟踪和评估进展
-----------------

* 你需要能够报告你在债务偿还活动中取得的进展。
* 采集一些指标，用于向管理和业务证明，花费在这些活动中的时间是值得的，这点特别重要::
  
    例如，很多时候你需要重构代码来提高性能，这时，手上有正确的统计数据来显示用户体验的改进是很重要的。

    同样，当你在改进一个简单的代码库时，添加新特性的速度是另一个向业务证明价值的重要指标。











* https://insights.thoughtworks.cn/managing-technical-debt/





